from typing import Any, Callable, TypeAlias

import casadi as ca
import numpy as np
from casadi.tools import entry, struct_symSX

FexplType: TypeAlias = Callable[[struct_symSX, ca.SX, dict[str, ca.SX], ca.SX], ca.SX]


def _define_param_struct(n_mass: int) -> struct_symSX:
    return struct_symSX(
        [
            entry("m", shape=(1,), repeat=n_mass - 1),
            entry("D", shape=(3,), repeat=n_mass - 1),
            entry("L", shape=(3,), repeat=n_mass - 1),
            entry("C", shape=(3,), repeat=n_mass - 1),
            entry("w", shape=(3,), repeat=n_mass - 2),
            entry("fix_point", shape=(3,)),
            entry("p_last", shape=(3,)),
        ]
    )


def _define_nlp_solver(
    n_mass: int, f_expl: FexplType
) -> tuple[ca.Function, struct_symSX, struct_symSX]:
    x = struct_symSX(
        [
            entry("pos", shape=(3, 1), repeat=n_mass - 1),
            entry("vel", shape=(3, 1), repeat=n_mass - 2),
        ]
    )
    xdot = ca.SX.sym("xdot", x.cat.shape)
    u = ca.SX.sym("u", 3, 1)
    p = _define_param_struct(n_mass)

    f_expl_out = f_expl(
        x=x,
        u=u,
        p={key: ca.vertcat(*p[key]) for key in ["m", "D", "L", "C", "w"]},
        fix_point=p["fix_point"],
    )
    g = ca.vertcat(xdot - f_expl_out, x["pos", -1] - p["p_last"], u)

    nlp = {"x": ca.vertcat(x.cat, xdot, u), "f": 0, "g": g, "p": p.cat}
    opts = {"print_time": False, "ipopt": {"print_level": 0, "sb": "yes"}}
    return ca.nlpsol("solver", "ipopt", nlp, opts), x(0), p(0)


class RestingChainSolver:
    """Computes the resting configuration of a chain given the position of the last mass."""

    def __init__(
        self,
        n_mass: int,
        f_expl: FexplType,
        fix_point: np.ndarray,
        m: np.ndarray,
        D: np.ndarray,
        C: np.ndarray,
        L: np.ndarray,
        **_: Any,
    ) -> None:
        self.n_mass = n_mass
        self.f_expl = f_expl
        self.nlp_solver, x0, p0 = _define_nlp_solver(n_mass=n_mass, f_expl=f_expl)

        p0["fix_point"] = fix_point  # Anchor point of the chain.

        # Extract parameter values from ChainParams
        for i_mass in range(n_mass - 1):
            p0["m", i_mass] = m[i_mass]
            p0["D", i_mass] = D[3 * i_mass : 3 * (i_mass + 1)]
            p0["C", i_mass] = C[3 * i_mass : 3 * (i_mass + 1)]
            p0["L", i_mass] = L[3 * i_mass : 3 * (i_mass + 1)]

        for i_pos in range(len(x0["pos"])):
            x0["pos", i_pos] = x0["pos", 0] + p0["L", i_pos] * (i_pos + 1)

        self.x0 = x0
        self.p0 = p0

    def __call__(self, p_last: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
        self.p0["p_last"] = p_last
        x0: np.ndarray = self.x0.cat.full().flatten()
        self.w0 = np.concatenate((x0, np.zeros(x0.size + 3)))
        sol = self.nlp_solver(x0=self.w0, lbg=0, ubg=0, p=self.p0.cat)

        nx = self.x0.cat.shape[0]
        x_ss = sol["x"].full()[:nx].flatten()
        u_ss = sol["x"].full()[-3:].flatten()
        return x_ss, u_ss
